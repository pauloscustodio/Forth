//-----------------------------------------------------------------------------
// C++ implementation of a Forth interpreter
// Copyright (c) Paulo Custodio, 2020-2025
// License: GPL3 https://www.gnu.org/licenses/gpl-3.0.html
//-----------------------------------------------------------------------------

#ifndef CONST
#define CONST(word, name, flags, value)
#endif

#ifndef VAR
#define VAR(word, name, flags, value)
#endif

#ifndef CODE
#define CODE(word, name, flags, c_code)
#endif

#ifndef FORTH
#define FORTH(word, name, flags, text)
#endif

// constants
CONST("BL", BL, 0, BL)
CODE("PAD", PAD, 0, push(mem_addr(vm.pad->pad())))
CONST("FALSE", FALSE, 0, F_FALSE)
CONST("TRUE", TRUE, 0, F_TRUE)


// base convsersion
VAR("BASE", BASE, 0, 10)
CODE("DECIMAL", DECIMAL, 0, vm.user->BASE = 10)
CODE("HEX", HEX, 0, vm.user->BASE = 16)


// arithmetic
CODE("+", PLUS, 0, push(pop() + pop()))
CODE("*", MULT, 0, push(pop()* pop()))
CODE("-", MINUS, 0, int b = pop(); push(pop() - b))
CODE("/", DIV, 0, int b = pop(); push(f_div(pop(), b)))
CODE("MOD", MOD, 0, int b = pop(); push(f_mod(pop(), b)))
CODE("/MOD", DIV_MOD, 0, f_div_mod())
CODE("*/", MULT_DIV, 0, f_mul_div())
CODE("*/MOD", MULT_DIV_MOD, 0, f_mul_div_mod())
CODE("FM/MOD", FM_DIV_MOD, 0, f_fm_div_mod())
CODE("UM/MOD", UM_DIV_MOD, 0, f_um_div_mod())
CODE("SM/REM", SM_DIV_REM, 0, f_sm_div_rem())
CODE("M*", M_STAR, 0, f_m_star())
CODE("1+", ONE_PLUS, 0, push(pop() + 1))
CODE("1-", ONE_MINUS, 0, push(pop() - 1))
CODE("2*", TWO_MULT, 0, push(pop() * 2))
CODE("2/", TWO_DIV, 0, push(f_div(pop(), 2)))
CODE("NEGATE", NEGATE, 0, push(-pop()))
CODE("S>D", S_TO_D, 0, dpush(pop()))
CODE("UM*", UM_MULT, 0, f_um_mult())
CODE("ABS", ABS, 0, push(f_abs(pop())))
CODE("MAX", FMAX, 0, push(f_max(pop(), pop())))
CODE("MIN", FMIN, 0, push(f_min(pop(), pop())))
CODE("CHAR+", CHAR_PLUS, 0, push(pop() + 1))
CODE("CHARS", CHARS, 0, push(pop() * 1))
CODE("CELL+", CELL_PLUS, 0, push(pop() + CELL_SZ))
CODE("CELLS", CELLS, 0, push(pop()* CELL_SZ))
CODE("WITHIN", WITHIN, 0, f_within())


// logical
CODE("AND", AND, 0, push(pop()& pop()))
CODE("OR", OR, 0, push(pop() | pop()))
CODE("XOR", XOR, 0, push(pop() ^ pop()))
CODE("INVERT", INVERT, 0, push(~pop()))
CODE("LSHIFT", LSHIFT, 0, uint count = pop(); uint n = pop(); push(n << count))
CODE("RSHIFT", RSHIFT, 0, uint count = pop(); uint n = pop(); push(n >> count))


// comparison
CODE("=", EQUAL, 0, push(f_bool(pop() == pop())))
CODE("<>", DIFFERENT, 0, push(f_bool(pop() != pop())))
CODE("<", LESS, 0, int b = pop(); push(f_bool(pop() < b)))
CODE(">", GREATER, 0, int b = pop(); push(f_bool(pop() > b)))
CODE("<=", LESS_EQUAL, 0, int b = pop(); push(f_bool(pop() <= b)))
CODE(">=", GREATER_EQUAL, 0, int b = pop(); push(f_bool(pop() >= b)))

CODE("U<", U_LESS, 0, unsigned int b = pop(); push(f_bool((unsigned)pop() < b)))
CODE("U>", U_GREATER, 0, unsigned int b = pop(); push(f_bool((unsigned)pop() > b)))
CODE("U<=", U_LESS_EQUAL, 0, unsigned int b = pop(); push(f_bool((unsigned)pop() <= b)))
CODE("U>=", U_GREATER_EQUAL, 0, unsigned int b = pop(); push(f_bool((unsigned)pop() >= b)))

CODE("0=", ZERO_EQUAL, 0, push(f_bool(pop() == 0)))
CODE("0<>", ZERO_DIFFERENT, 0, push(f_bool(pop() != 0)))
CODE("0<", ZERO_LESS, 0, push(f_bool(pop() < 0)))
CODE("0>", ZERO_GREATER, 0, push(f_bool(pop() > 0)))
CODE("0<=", ZERO_LESS_EQUAL, 0, push(f_bool(pop() <= 0)))
CODE("0>=", ZERO_GREATER_EQUAL, 0, push(f_bool(pop() >= 0)))



// memory
CODE("!", STORE, 0, int a = pop(); store(a, pop()))
CODE("@", FETCH, 0, push(fetch(pop())))
CODE("+!", PLUS_STORE, 0, int a = pop(); store(a, fetch(a) + pop()))
CODE("C!", CSTORE, 0, int a = pop(); cstore(a, pop()))
CODE("C@", CFETCH, 0, push(cfetch(pop())))
CODE("2!", TWO_STORE, 0, int a = pop(); dstore(a, dpop()))
CODE("2@", TWO_FETCH, 0, dpush(dfetch(pop())))
CODE("FILL", FILL, 0, f_fill())
CODE("ERASE", ERASE, 0, f_erase())
CODE("MOVE", MOVE, 0, f_move())


// parameter stack
CODE("DROP", DROP, 0, pop())
CODE("SWAP", SWAP, 0, int a = pop(); int b = pop(); push(a); push(b))
CODE("DUP", DUP, 0, push(peek(0)))
CODE("?DUP", QDUP, 0, int a = peek(0); if (a) push(a))
CODE("OVER", OVER, 0, push(peek(1)))
CODE("ROT", ROT, 0, int c = pop(); int b = pop(); int a = pop(); push(b); push(c); push(a))
CODE("-ROT", MINUS_ROT, 0, int c = pop(); int b = pop(); int a = pop(); push(c); push(a); push(b))

CODE("DEPTH", DEPTH, 0, push(depth()))
CODE("NIP", NIP, 0, int a = pop(); pop(); push(a))
CODE("PICK", PICK, 0, push(peek(pop())))
CODE("ROLL", ROLL, 0, roll(pop()))
CODE("TUCK", TUCK, 0, int a = pop(); int b = pop(); push(a); push(b); push(a))

CODE("2DROP", TWO_DROP, 0, dpop())
CODE("2SWAP", TWO_SWAP, 0, dint a = dpop(); dint b = dpop(); dpush(a); dpush(b))
CODE("2DUP", TWO_DUP, 0, push(peek(1)); push(peek(1)))
CODE("2OVER", TWO_OVER, 0, push(peek(3)); push(peek(3)))
CODE("2ROT", TWO_ROT, 0, dint c = dpop(); dint b = dpop(); dint a = dpop(); dpush(b); dpush(c); dpush(a))
CODE("-2ROT", MINUS_2ROT, 0, dint c = dpop(); dint b = dpop(); dint a = dpop(); dpush(c); dpush(a); dpush(b))

CONST("S0", S0, 0, STACK_SZ)
CODE("SP@", SPFETCH, 0, push(vm.stack->sp()))
CODE("SP!", SPSTORE, 0, vm.stack->set_sp(pop()))


// return stack
CODE(">R", TOR, 0, r_push(pop()))
CODE("R>", FROMR, 0, push(r_pop()))
CODE("R@", R_FETCH, 0, push(r_peek(0)))
CODE("I", I, 0, push(r_peek(0)))
CODE("J", J, 0, push(r_peek(2)))
CODE("2>R", TWO_TO_R, 0, r_dpush(dpop()))
CODE("2R>", TWO_R_TO, 0, dpush(r_dpop()))
CODE("2R@", TWO_R_FETCH, 0, dpush(r_dpeek(0)))
CODE("RDROP", RDROP, 0, r_pop())

CONST("R0", R0, 0, STACK_SZ)
CODE("RSP@", RSP_FETCH, 0, push(vm.r_stack->sp()))
CODE("RSP!", RSP_STORE, 0, vm.r_stack->set_sp(pop()))


// dictionary
CODE(",", COMMA, 0, comma(pop()))
CODE("C,", CCOMMA, 0, ccomma(pop()))
CODE("HERE", HERE, 0, push(vm.dict->here()))
CODE("LATEST", LATEST, 0, push(vm.dict->latest()))
CODE("FIND", FIND, 0, f_find(pop()))
CODE(">BODY", TO_BODY, 0, push(pop() + CELL_SZ))
CODE("ALIGN", ALIGN, 0, vm.dict->align())
CODE("ALIGNED", ALIGNED, 0, push(aligned(pop())))
CODE("ALLOT", ALLOT, 0, vm.dict->allot(pop()))
CODE("UNUSED", UNUSED, 0, push(vm.dict->unused()))

CODE("MARKER", MARKER, 0, f_marker())
CODE("(MARKER)", XMARKER, F_HIDDEN, f_xmarker(body))


// parser
CODE("WORD", WORD, 0, push(f_word(pop())))
CODE("PARSE", PARSE, 0, f_parse(pop()))
CODE("PARSE-WORD", PARSE_WORD, 0, f_parse_name())
CODE("PARSE-NAME", PARSE_NAME, 0, f_parse_name())

CODE("CHAR", CHAR, 0, push(f_char(BL)))
CODE("[CHAR]", BRACKET_CHAR, F_IMMEDIATE, f_bracket_char(BL))

VAR("DPL", DPL, 0, 0)
CODE("NUMBER?", NUMBERQ, 0, f_number_q())
CODE("NUMBER", NUMBER, 0, f_number())
CODE(">NUMBER", TO_NUMBER, 0, f_to_number())
CODE("CONVERT", CONVERT, 0, f_convert())


// strings
CODE("COUNT", COUNT, 0, f_count())
CODE(".\"", DOT_QUOTE, F_IMMEDIATE, f_dot_quote())
CODE("(.\")", XDOT_QUOTE, F_HIDDEN, f_xdot_quote())
CODE("S\"", S_QUOTE, F_IMMEDIATE, f_s_quote())
CODE("S\\\"", S_BACKSLASH_QUOTE, F_IMMEDIATE, f_s_backslash_quote())
CODE("(S\")", XS_QUOTE, F_HIDDEN, f_xs_quote())
CODE("C\"", C_QUOTE, F_IMMEDIATE, f_c_quote())
CODE("(C\")", XC_QUOTE, F_HIDDEN, f_xc_quote())
CODE(".(", DOT_PAREN, F_IMMEDIATE, f_dot_paren())


// input
VAR(">IN", TO_IN, 0, 0)
VAR("#IN", NR_IN, 0, 0)
CODE("SOURCE", SOURCE, 0, f_source())
CODE("TIB", TIB, 0, f_tib())
CODE("#TIB", NRTIB, 0, push(mem_addr(&vm.user->NR_IN)))
CODE("SOURCE-ID", SOURCE_ID, 0, push(vm.input->source_id()))

CODE("REFILL", REFILL, 0, push(f_bool(f_refill())))
CODE("ACCEPT", ACCEPT, 0, f_accept())
CODE("KEY", KEY, 0, push(f_key()))

VAR("SPAN", SPAN, 0, 0)
CODE("EXPECT", EXPECT, 0, f_expect())

CODE("QUERY", QUERY, 0, f_query())

CODE("SAVE-INPUT", SAVE_INPUT, 0, f_save_input())
CODE("RESTORE-INPUT", RESTORE_INPUT, 0, push(f_bool(f_restore_input())))


// output
CODE("TYPE", TYPE, 0, int size = pop(); int addr = pop(); print_string(addr, size))
CODE("EMIT", EMIT, 0, print_char(pop()))
CODE("CR", CR, 0, print_char(CR))
CODE("SPACE", SPACE, 0, print_char(BL))
CODE("SPACES", SPACES, 0, print_spaces(pop()))

CODE("<#", LESS_HASH, 0, vm.number_output->start())
CODE("#", HASH, 0, vm.number_output->add_digit())
CODE("#S", HASH_S, 0, vm.number_output->add_digits())
CODE("HOLD", HOLD, 0, vm.number_output->add_char(pop()))
CODE("HOLDS", HOLDS, 0, int size = pop(); int addr = pop(); vm.number_output->add_string(mem_char_ptr(addr), size))
CODE("SIGN", SIGN, 0, vm.number_output->add_sign(pop()))
CODE("#>", HASH_GREATER, 0, vm.number_output->end())

CODE(".", DOT, 0, print_number(pop()))
CODE("?", Q, 0, print_number(peek()))
CODE("D.", DDOT, 0, print_number(dpop()))
CODE("D.R", DDOTR, 0, int w = pop(); print_number(dpop(), w))
CODE("U.", U_DOT, 0, print_unsigned_number((int)pop()))
CODE(".R", DOT_R, 0, int w = pop(); print_number(pop(), w))
CODE("U.R", U_DOT_R, 0, int w = pop(); print_unsigned_number((int)pop(), w))


// inner interpreter
VAR("TRACE", TRACE, 0, F_FALSE)
CODE("INTERPRET", INTERPRET, 0, f_interpret())
CODE("EVALUATE", EVALUATE, 0, f_evaluate())
CODE("EXECUTE", EXECUTE, 0, f_execute(pop()))
CODE("EXIT", EXIT, 0, if (r_depth() == 0) do_exit = true; else vm.ip = r_pop())


// compiler
VAR("STATE", STATE, 0, STATE_INTERPRET)
CODE(":", COLON, 0, f_colon())
CODE(":NONAME", COLON_NONAME, 0, f_colon_noname())
CODE(";", SEMICOLON, F_IMMEDIATE, f_semicolon())
CODE("(DOCOL)", XDOCOL, F_HIDDEN, r_push(vm.ip); vm.ip = body)
CODE("(SEMICOLON)", XSEMICOLON, F_HIDDEN, if (r_depth() == 0) do_exit = true; else vm.ip = r_pop())

CODE("[", LBRACKET, F_IMMEDIATE, vm.user->STATE = STATE_INTERPRET)
CODE("]", RBRACKET, 0, vm.user->STATE = STATE_COMPILE)

CODE("'", TICK, 0, push(f_tick()))
CODE("[']", BRACKET_TICK, F_IMMEDIATE, f_bracket_tick())

CODE("CREATE", CREATE, 0, f_create())
CODE("VARIABLE", VARIABLE, 0, f_variable())
CODE("(DOVAR)", XDOVAR, F_HIDDEN, push(body))
CODE("BUFFER:", BUFFER_COLON, 0, f_buffer_colon())

CODE("VALUE", VALUE, 0, f_value())
CODE("2VALUE", TWO_VALUE, 0, f_two_value())
CODE("TO", TO, F_IMMEDIATE, f_to())

CODE("CONSTANT", CONSTANT, 0, f_constant())
CODE("(DOCONST)", XDOCONST, F_HIDDEN, push(fetch(body)))

CODE("LITERAL", LITERAL, F_IMMEDIATE, comma(xtXLITERAL); comma(pop()))
CODE("(LITERAL)", XLITERAL, F_HIDDEN, push(fetch(vm.ip)); vm.ip += CELL_SZ)

CODE("DOES>", DOES, F_IMMEDIATE, f_does())
CODE("(DOES>DEFINE)", XDOES_DEFINE, F_HIDDEN, f_xdoes_define())
CODE("(DOES>RUN)", XDOES_RUN, F_HIDDEN, f_xdoes_run(body))

CODE("POSTPONE", POSTPONE, F_IMMEDIATE, f_postpone())
CODE("IMMEDIATE", IMMEDIATE, 0, f_immediate())
CODE("COMPILE,", COMPILE_COMMA, F_IMMEDIATE, f_compile_comma())
CODE("[COMPILE]", BRACKET_COMPILE, F_IMMEDIATE, f_bracket_compile())

CODE("DEFER", DEFER, 0, f_defer())
CODE("(DEFER)", XDEFER, F_HIDDEN, f_xdefer(body))
CODE("DEFER@", DEFER_FETCH, 0, f_defer_fetch(pop()))
CODE("DEFER!", DEFER_STORE, 0, f_defer_store())
CODE("ACTION-OF", ACTION_OF, F_IMMEDIATE, f_action_of())
CODE("IS", IS, F_IMMEDIATE, f_is())

CODE("(", OPEN_PAREN, F_IMMEDIATE, f_open_paren())
CODE("\\", BACKSLASH, F_IMMEDIATE, f_backslash())

// control flow
CODE("BRANCH", BRANCH, F_HIDDEN, vm.ip += fetch(vm.ip))
CODE("0BRANCH", ZBRANCH, F_HIDDEN, if (!pop()) vm.ip += fetch(vm.ip); else vm.ip += CELL_SZ)

CODE("IF", IF, F_IMMEDIATE, f_if())
CODE("ELSE", ELSE, F_IMMEDIATE, f_else())
CODE("THEN", THEN, F_IMMEDIATE, f_then())

CODE("DO", DO, F_IMMEDIATE, f_do())
CODE("(DO)", XDO, F_HIDDEN, f_xdo())
CODE("?DO", QUERY_DO, F_IMMEDIATE, f_query_do())
CODE("(?DO)", XQUERY_DO, F_HIDDEN, f_xquery_do())
CODE("LOOP", LOOP, F_IMMEDIATE, f_loop())
CODE("(LOOP)", XLOOP, F_HIDDEN, f_xloop())
CODE("+LOOP", PLUS_LOOP, F_IMMEDIATE, f_plus_loop())
CODE("(+LOOP)", XPLUS_LOOP, F_HIDDEN, f_xplus_loop())
CODE("LEAVE", LEAVE, F_IMMEDIATE, f_leave())
CODE("(LEAVE)", XLEAVE, F_HIDDEN, f_xleave())
CODE("UNLOOP", UNLOOP, F_IMMEDIATE, f_unloop())
CODE("(UNLOOP)", XUNLOOP, F_HIDDEN, f_xunloop())

CODE("BEGIN", BEGIN, F_IMMEDIATE, f_begin())
CODE("AGAIN", AGAIN, F_IMMEDIATE, f_again())
CODE("UNTIL", UNTIL, F_IMMEDIATE, f_until())
CODE("WHILE", WHILE, F_IMMEDIATE, f_while())
CODE("REPEAT", REPEAT, F_IMMEDIATE, f_repeat())
CODE("RECURSE", RECURSE, F_IMMEDIATE, f_recurse())

CODE("CASE", CASE, F_IMMEDIATE, f_case())
CODE("OF", OF, F_IMMEDIATE, f_of())
CODE("(OF)", XOF, F_HIDDEN, f_xof())
CODE("ENDOF", ENDOF, F_IMMEDIATE, f_endof())
CODE("ENDCASE", ENDCASE, F_IMMEDIATE, f_endcase())


// main loop
CODE("QUIT", QUIT, 0, f_quit())
CODE("BYE", BYE, 0, exit(EXIT_SUCCESS))
CODE("ABORT", ABORT, 0, exit(EXIT_FAILURE))
CODE("ABORT\"", ABORT_QUOTE, F_IMMEDIATE, f_abort_quote())
CODE("(ABORT\")", XABORT_QUOTE, F_HIDDEN, f_xabort_quote())


// blocks
VAR("BLK", BLK, 0, 0)
VAR("SCR", SCR, 0, 0)
CODE("BLOCK", BLOCK, 0, f_block())
CODE("BUFFER", BUFFER, 0, f_block())
CODE("SAVE-BUFFERS", SAVE_BUFFERS, 0, f_save_buffers())
CODE("EMPTY-BUFFERS", EMPTY_BUFFERS, 0, f_empty_buffers())
CODE("FLUSH", FLUSH, 0, f_flush())
CODE("LOAD", LOAD, 0, f_load())
CODE("UPDATE", UPDATE, 0, f_update())
CODE("LIST", LIST, 0, f_list())
CODE("THRU", THRU, 0, f_thru())


// tools
CODE(".S", DOT_S, 0, vm.stack->print())
CODE(".RS", DOT_RS, 0, vm.r_stack->print())
CODE("WORDS", WORDS, 0, f_words())
CODE("ENVIRONMENT?", ENVIRONMENT_Q, 0, f_environment_q())
CODE("DUMP", DUMP, 0, f_dump())
CODE("SEE", SEE, 0, f_see())
CODE("ON", ON, 0, store(pop(), F_TRUE))
CODE("OFF", OFF, 0, store(pop(), F_FALSE))


// double
CODE("2CONSTANT", TWO_CONSTANT, 0, f_2constant())
CODE("(DO2CONST)", XDO2CONST, F_HIDDEN, dpush(dfetch(body)))

CODE("2VARIABLE", TWO_VARIABLE, 0, f_2variable())

CODE("2LITERAL", TWO_LITERAL, F_IMMEDIATE, comma(xtX2LITERAL); dcomma(dpop()))
CODE("(2LITERAL)", X2LITERAL, F_HIDDEN, dpush(dfetch(vm.ip)); vm.ip += DCELL_SZ)

CODE("D+", DPLUS, 0, dpush(dpop() + dpop()))
CODE("D-", DMINUS, 0, dint b = dpop(); dpush(dpop() - b))

CODE("D2*", D2MULT, 0, dpush(dpop() << 1))
CODE("D2/", D2DIV, 0, dpush(dpop() >> 1))

CODE("M*/", MSTARDIV, 0, f_m_star_slash())
CODE("M+", MPLUS, 0, f_m_plus())

CODE("D=", DEQUAL, 0, push(f_bool(dpop() == dpop())))
CODE("D<>", DDIFFERENT, 0, push(f_bool(dpop() != dpop())))
CODE("D<", DLESS, 0, dint b = dpop(); push(f_bool(dpop() < b)))
CODE("D<=", DLESS_EQUAL, 0, dint b = dpop(); push(f_bool(dpop() <= b)))
CODE("D>", DGREATER, 0, dint b = dpop(); push(f_bool(dpop() > b)))
CODE("D>=", DGREATER_EQUAL, 0, dint b = dpop(); push(f_bool(dpop() >= b)))

CODE("DU<", DU_LESS, 0, udint b = dpop(); push(f_bool((udint)dpop() < b)))
CODE("DU<=", DU_LESS_EQUAL, 0, udint b = dpop(); push(f_bool((udint)dpop() <= b)))
CODE("DU>", DU_GREATER, 0, udint b = dpop(); push(f_bool((udint)dpop() > b)))
CODE("DU>=", DU_GREATER_EQUAL, 0, udint b = dpop(); push(f_bool((udint)dpop() >= b)))

CODE("D0=", DZERO_EQUAL, 0, push(f_bool(dpop() == 0)))
CODE("D0<>", DZERO_DIFFERENT, 0, push(f_bool(dpop() != 0)))
CODE("D0<", DZERO_LESS, 0, push(f_bool(dpop() < 0)))
CODE("D0<=", DZERO_LESS_EQUAL, 0, push(f_bool(dpop() <= 0)))
CODE("D0>", DZERO_GREATER, 0, push(f_bool(dpop() > 0)))
CODE("D0>=", DZERO_GREATER_EQUAL, 0, push(f_bool(dpop() >= 0)))

CODE("D>S", DTOS, 0, push(dcell_lo(dpop())))

CODE("DABS", DABS, 0, dpush(f_dabs(dpop())))
CODE("DMAX", DMAX, 0, dpush(f_dmax(dpop(), dpop())))
CODE("DMIN", DMIN, 0, dpush(f_dmin(dpop(), dpop())))
CODE("DNEGATE", DNEGATE, 0, dpush(-dpop()))


// files
CODE("INCLUDED", INCLUDED, 0, f_included())


#undef CONST
#undef VAR
#undef CODE
#undef FORTH
