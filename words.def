//-----------------------------------------------------------------------------
// C++ implementation of a Forth interpreter
// Copyright (c) Paulo Custodio, 2020-2025
// License: GPL3 https://www.gnu.org/licenses/gpl-3.0.html
//-----------------------------------------------------------------------------

#ifndef CONST
#define CONST(word, name, flags, value)
#endif

#ifndef VAR
#define VAR(word, name, flags, value)
#endif

#ifndef CODE
#define CODE(word, name, flags, c_code)
#endif

#ifndef FORTH
#define FORTH(word, name, flags, text)
#endif

// constants
CONST("BL", BL, 0, BL)
CODE("PAD", PAD, 0, push(mem_addr(vm.pad_data)))
CONST("FALSE", FALSE, 0, F_FALSE)
CONST("TRUE", TRUE, 0, F_TRUE)


// base convsersion
VAR("BASE", BASE, 0, 10)
CODE("DECIMAL", DECIMAL, 0, vm.user->BASE = 10)
CODE("HEX", HEX, 0, vm.user->BASE = 16)


// arithmetic
CODE("+", PLUS, 0, push(pop() + pop()))
CODE("*", MULT, 0, push(pop()* pop()))
CODE("-", MINUS, 0, int b = pop(); push(pop() - b))
CODE("/", DIV, 0, int b = pop(); push(f_div(pop(), b)))
CODE("MOD", MOD, 0, int b = pop(); push(f_mod(pop(), b)))
CODE("/MOD", DIV_MOD, 0, f_div_mod())
CODE("*/", MULT_DIV, 0, f_mul_div())
CODE("*/MOD", MULT_DIV_MOD, 0, f_mul_div_mod())
CODE("FM/MOD", FM_DIV_MOD, 0, f_fm_div_mod())
CODE("UM/MOD", UM_DIV_MOD, 0, f_um_div_mod())
CODE("SM/REM", SM_DIV_REM, 0, f_sm_div_rem())
CODE("M*", M_STAR, 0, f_m_star())
CODE("1+", ONE_PLUS, 0, push(pop() + 1))
CODE("1-", ONE_MINUS, 0, push(pop() - 1))
CODE("2*", TWO_MULT, 0, push(pop() * 2))
CODE("2/", TWO_DIV, 0, push(f_div(pop(), 2)))
CODE("NEGATE", NEGATE, 0, push(-pop()))
CODE("S>D", S_TO_D, 0, dpush(pop()))
CODE("UM*", UM_MULT, 0, f_um_mult())
CODE("ABS", ABS, 0, push(std::abs(pop())))
CODE("MAX", MAX, 0, push(std::max(pop(), pop())))
CODE("MIN", MIN, 0, push(std::min(pop(), pop())))
CODE("CHAR+", CHAR_PLUS, 0, push(pop() + 1))
CODE("CHARS", CHARS, 0, push(pop() * 1))
CODE("CELL+", CELL_PLUS, 0, push(pop() + CELL_SZ))
CODE("CELLS", CELLS, 0, push(pop()* CELL_SZ))
CODE("WITHIN", WITHIN, 0, f_within())


// logical
CODE("AND", AND, 0, push(pop()& pop()))
CODE("OR", OR, 0, push(pop() | pop()))
CODE("XOR", XOR, 0, push(pop() ^ pop()))
CODE("INVERT", INVERT, 0, push(~pop()))
CODE("LSHIFT", LSHIFT, 0, uint count = pop(); uint n = pop(); push(n << count))
CODE("RSHIFT", RSHIFT, 0, uint count = pop(); uint n = pop(); push(n >> count))


// comparison
CODE("=", EQUAL, 0, push(f_bool(pop() == pop())))
CODE("<>", DIFFERENT, 0, push(f_bool(pop() != pop())))
CODE("<", LESS, 0, int b = pop(); push(f_bool(pop() < b)))
CODE(">", GREATER, 0, int b = pop(); push(f_bool(pop() > b)))
CODE("<=", LESS_EQUAL, 0, int b = pop(); push(f_bool(pop() <= b)))
CODE(">=", GREATER_EQUAL, 0, int b = pop(); push(f_bool(pop() >= b)))

CODE("U<", U_LESS, 0, unsigned int b = pop(); push(f_bool((unsigned)pop() < b)))
CODE("U>", U_GREATER, 0, unsigned int b = pop(); push(f_bool((unsigned)pop() > b)))
CODE("U<=", U_LESS_EQUAL, 0, unsigned int b = pop(); push(f_bool((unsigned)pop() <= b)))
CODE("U>=", U_GREATER_EQUAL, 0, unsigned int b = pop(); push(f_bool((unsigned)pop() >= b)))

CODE("0=", ZERO_EQUAL, 0, push(f_bool(pop() == 0)))
CODE("0<>", ZERO_DIFFERENT, 0, push(f_bool(pop() != 0)))
CODE("0<", ZERO_LESS, 0, push(f_bool(pop() < 0)))
CODE("0>", ZERO_GREATER, 0, push(f_bool(pop() > 0)))
CODE("0<=", ZERO_LESS_EQUAL, 0, push(f_bool(pop() <= 0)))
CODE("0>=", ZERO_GREATER_EQUAL, 0, push(f_bool(pop() >= 0)))



// memory
CODE("!", STORE, 0, uint a = pop(); store(a, pop()))
CODE("@", FETCH, 0, push(fetch(pop())))
CODE("+!", PLUS_STORE, 0, uint a = pop(); store(a, fetch(a) + pop()))
CODE("C!", CSTORE, 0, uint a = pop(); cstore(a, pop()))
CODE("C@", CFETCH, 0, push(cfetch(pop())))
CODE("2!", TWO_STORE, 0, uint a = pop(); dstore(a, dpop()))
CODE("2@", TWO_FETCH, 0, dpush(dfetch(pop())))
CODE("FILL", FILL, 0, f_fill())
CODE("ERASE", ERASE, 0, f_erase())
CODE("MOVE", MOVE, 0, f_move())


// parameter stack
CODE("DROP", DROP, 0, pop())
CODE("SWAP", SWAP, 0, int a = pop(); int b = pop(); push(a); push(b))
CODE("DUP", DUP, 0, push(peek(0)))
CODE("?DUP", QDUP, 0, int a = peek(0); if (a) push(a))
CODE("OVER", OVER, 0, push(peek(1)))
CODE("ROT", ROT, 0, int c = pop(); int b = pop(); int a = pop(); push(b); push(c); push(a))
CODE("-ROT", MINUS_ROT, 0, int c = pop(); int b = pop(); int a = pop(); push(c); push(a); push(b))

CODE("DEPTH", DEPTH, 0, push(depth()))
CODE("NIP", NIP, 0, int a = pop(); pop(); push(a))
CODE("PICK", PICK, 0, push(peek(pop())))
CODE("ROLL", ROLL, 0, roll(pop()))
CODE("TUCK", TUCK, 0, int a = pop(); int b = pop(); push(a); push(b); push(a))

CODE("2DROP", TWO_DROP, 0, dpop())
CODE("2SWAP", TWO_SWAP, 0, dint a = dpop(); dint b = dpop(); dpush(a); dpush(b))
CODE("2DUP", TWO_DUP, 0, push(peek(1)); push(peek(1)))
CODE("2OVER", TWO_OVER, 0, push(peek(3)); push(peek(3)))
CODE("2ROT", TWO_ROT, 0, dint c = dpop(); dint b = dpop(); dint a = dpop(); dpush(b); dpush(c); dpush(a))
CODE("-2ROT", MINUS_2ROT, 0, dint c = dpop(); dint b = dpop(); dint a = dpop(); dpush(c); dpush(a); dpush(b))

CONST("S0", S0, 0, STACK_SZ)
CODE("SP@", SPFETCH, 0, push(vm.stack.sp()))
CODE("SP!", SPSTORE, 0, vm.stack.set_sp(pop()))


// return stack
CODE(">R", TOR, 0, r_push(pop()))
CODE("R>", FROMR, 0, push(r_pop()))
CODE("R@", R_FETCH, 0, push(r_peek(0)))
CODE("I", I, 0, push(r_peek(0)))
CODE("J", J, 0, push(r_peek(2)))
CODE("2>R", TWO_TO_R, 0, r_dpush(dpop()))
CODE("2R>", TWO_R_TO, 0, dpush(r_dpop()))
CODE("2R@", TWO_R_FETCH, 0, dpush(r_dpeek(0)))
CODE("RDROP", RDROP, 0, r_pop())

CONST("R0", R0, 0, STACK_SZ)
CODE("RSP@", RSP_FETCH, 0, push(vm.r_stack.sp()))
CODE("RSP!", RSP_STORE, 0, vm.r_stack.set_sp(pop()))


// dictionary
CODE(",", COMMA, 0, comma(pop()))
CODE("C,", CCOMMA, 0, ccomma(pop()))
CODE("HERE", HERE, 0, push(vm.here))
CODE("LATEST", LATEST, 0, push(vm.latest))
CODE("FIND", FIND, 0, f_find(pop()))
CODE(">BODY", TO_BODY, 0, push(pop() + CELL_SZ))
CODE("ALIGN", ALIGN, 0, vm.dict.align())
CODE("ALIGNED", ALIGNED, 0, push(aligned(pop())))
CODE("ALLOT", ALLOT, 0, vm.dict.allot(pop()))
CODE("UNUSED", UNUSED, 0, push(vm.dict.unused()))

CODE("MARKER", MARKER, 0, f_marker())
CODE("(MARKER)", XMARKER, F_HIDDEN, f_xmarker(body))


// parser
CODE("WORD", WORD, 0, push(f_word(pop())))
CODE("PARSE", PARSE, 0, f_parse(pop()))
CODE("PARSE-WORD", PARSE_WORD, 0, f_parse_name())
CODE("PARSE-NAME", PARSE_NAME, 0, f_parse_name())

CODE("CHAR", CHAR, 0, push(f_char(BL)))
CODE("[CHAR]", BRACKET_CHAR, F_IMMEDIATE, f_bracket_char(BL))

VAR("DPL", DPL, 0, 0)
CODE("NUMBER?", NUMBERQ, 0, f_number_q())
CODE("NUMBER", NUMBER, 0, f_number())
CODE(">NUMBER", TO_NUMBER, 0, f_to_number())
CODE("CONVERT", CONVERT, 0, f_convert())


// strings
CODE("COUNT", COUNT, 0, f_count())
CODE(".\"", DOT_QUOTE, F_IMMEDIATE, f_dot_quote())
CODE("(.\")", XDOT_QUOTE, F_HIDDEN, f_xdot_quote())
CODE("S\"", S_QUOTE, F_IMMEDIATE, f_s_quote())
CODE("S\\\"", S_BACKSLASH_QUOTE, F_IMMEDIATE, f_s_backslash_quote())
CODE("(S\")", XS_QUOTE, F_HIDDEN, f_xs_quote())
CODE("C\"", C_QUOTE, F_IMMEDIATE, f_c_quote())
CODE("(C\")", XC_QUOTE, F_HIDDEN, f_xc_quote())
CODE(".(", DOT_PAREN, F_IMMEDIATE, f_dot_paren())


// input
VAR(">IN", TO_IN, 0, 0)
VAR("#IN", NR_IN, 0, 0)
CODE("SOURCE", SOURCE, 0, f_source())
CODE("TIB", TIB, 0, f_tib())
CODE("#TIB", NRTIB, 0, push(mem_addr(&vm.user->NR_IN)))
CODE("SOURCE-ID", SOURCE_ID, 0, push(vm.input.source_id()))

CODE("REFILL", REFILL, 0, push(f_bool(f_refill())))
CODE("ACCEPT", ACCEPT, 0, f_accept())

VAR("SPAN", SPAN, 0, 0)
CODE("EXPECT", EXPECT, 0, f_expect())

CODE("QUERY", QUERY, 0, f_query())

CODE("SAVE-INPUT", SAVE_INPUT, 0, f_save_input())
CODE("RESTORE-INPUT", RESTORE_INPUT, 0, push(f_bool(f_restore_input())))


// output
CODE("TYPE", TYPE, 0, uint size = pop(); uint addr = pop(); print_string(addr, size))
CODE("EMIT", EMIT, 0, print_char(pop()))
CODE("CR", CR, 0, print_char(CR))
CODE("SPACE", SPACE, 0, print_char(BL))
CODE("SPACES", SPACES, 0, print_spaces(pop()))

CODE("<#", LESS_HASH, 0, vm.number_output.start())
CODE("#", HASH, 0, vm.number_output.add_digit())
CODE("#S", HASH_S, 0, vm.number_output.add_digits())
CODE("HOLD", HOLD, 0, vm.number_output.add_char(pop()))
CODE("HOLDS", HOLDS, 0, uint size = pop(); uint addr = pop(); vm.number_output.add_string(mem_char_ptr(addr, size), size))
CODE("SIGN", SIGN, 0, vm.number_output.add_sign(pop()))
CODE("#>", HASH_GREATER, 0, vm.number_output.end())

CODE(".", DOT, 0, print_number(pop()))
CODE("?", Q, 0, print_number(peek()))
CODE("D.", DDOT, 0, print_number(dpop()))
CODE("D.R", DDOTR, 0, int w = pop(); print_number(dpop(), w))
CODE("U.", U_DOT, 0, print_unsigned_number((int)pop()))
CODE(".R", DOT_R, 0, int w = pop(); print_number(pop(), w))
CODE("U.R", U_DOT_R, 0, int w = pop(); print_unsigned_number((int)pop(), w))


// inner interpreter
VAR("TRACE", TRACE, 0, F_FALSE)
CODE("INTERPRET", INTERPRET, 0, f_interpret())
CODE("EVALUATE", EVALUATE, 0, f_evaluate())
CODE("EXECUTE", EXECUTE, 0, f_execute(pop()))
CODE("EXIT", EXIT, 0, if (r_depth() == 0) do_exit = true; else leave_func())


// compiler
VAR("STATE", STATE, 0, STATE_INTERPRET)
CODE(":", COLON, 0, f_colon())
CODE(":NONAME", COLON_NONAME, 0, f_colon_noname())
CODE(";", SEMICOLON, F_IMMEDIATE, f_semicolon())
CODE("(DOCOL)", XDOCOL, F_HIDDEN, enter_func(body))

CODE("[", LBRACKET, F_IMMEDIATE, vm.user->STATE = STATE_INTERPRET)
CODE("]", RBRACKET, 0, vm.user->STATE = STATE_COMPILE)

CODE("'", TICK, 0, push(f_tick()))
CODE("[']", BRACKET_TICK, F_IMMEDIATE, f_bracket_tick())

CODE("CREATE", CREATE, 0, f_create())
CODE("VARIABLE", VARIABLE, 0, f_variable())
CODE("(DOVAR)", XDOVAR, F_HIDDEN, push(body))
CODE("BUFFER:", BUFFER_COLON, 0, f_buffer_colon())

CODE("VALUE", VALUE, 0, f_value())
CODE("2VALUE", TWO_VALUE, 0, f_two_value())
CODE("FVALUE", FVALUE, 0, f_fvalue())
CODE("TO", TO, F_IMMEDIATE, f_to())

CODE("CONSTANT", CONSTANT, 0, f_constant())
CODE("(DOCONST)", XDOCONST, F_HIDDEN, push(fetch(body)))

CODE("LITERAL", LITERAL, F_IMMEDIATE, comma(xtXLITERAL); comma(pop()))
CODE("(LITERAL)", XLITERAL, F_HIDDEN, push(fetch(vm.ip)); vm.ip += CELL_SZ)

CODE("DOES>", DOES, F_IMMEDIATE, f_does())
CODE("(DOES>DEFINE)", XDOES_DEFINE, F_HIDDEN, f_xdoes_define())
CODE("(DOES>RUN)", XDOES_RUN, F_HIDDEN, f_xdoes_run(body))

CODE("POSTPONE", POSTPONE, F_IMMEDIATE, f_postpone())
CODE("IMMEDIATE", IMMEDIATE, 0, f_immediate())
CODE("COMPILE,", COMPILE_COMMA, F_IMMEDIATE, f_compile_comma())
CODE("[COMPILE]", BRACKET_COMPILE, F_IMMEDIATE, f_bracket_compile())

CODE("DEFER", DEFER, 0, f_defer())
CODE("(DEFER)", XDEFER, F_HIDDEN, f_xdefer(body))
CODE("DEFER@", DEFER_FETCH, 0, f_defer_fetch(pop()))
CODE("DEFER!", DEFER_STORE, 0, f_defer_store())
CODE("ACTION-OF", ACTION_OF, F_IMMEDIATE, f_action_of())
CODE("IS", IS, F_IMMEDIATE, f_is())

CODE("(", OPEN_PAREN, F_IMMEDIATE, f_open_paren())
CODE("\\", BACKSLASH, F_IMMEDIATE, f_backslash())

// control flow
CODE("BRANCH", BRANCH, F_HIDDEN, vm.ip += fetch(vm.ip))
CODE("0BRANCH", ZBRANCH, F_HIDDEN, if (!pop()) vm.ip += fetch(vm.ip); else vm.ip += CELL_SZ)

CODE("IF", IF, F_IMMEDIATE, f_if())
CODE("ELSE", ELSE, F_IMMEDIATE, f_else())
CODE("THEN", THEN, F_IMMEDIATE, f_then())

CODE("DO", DO, F_IMMEDIATE, f_do())
CODE("(DO)", XDO, F_HIDDEN, f_xdo())
CODE("?DO", QUERY_DO, F_IMMEDIATE, f_query_do())
CODE("(?DO)", XQUERY_DO, F_HIDDEN, f_xquery_do())
CODE("LOOP", LOOP, F_IMMEDIATE, f_loop())
CODE("(LOOP)", XLOOP, F_HIDDEN, f_xloop())
CODE("+LOOP", PLUS_LOOP, F_IMMEDIATE, f_plus_loop())
CODE("(+LOOP)", XPLUS_LOOP, F_HIDDEN, f_xplus_loop())
CODE("LEAVE", LEAVE, F_IMMEDIATE, f_leave())
CODE("(LEAVE)", XLEAVE, F_HIDDEN, f_xleave())
CODE("UNLOOP", UNLOOP, F_IMMEDIATE, f_unloop())
CODE("(UNLOOP)", XUNLOOP, F_HIDDEN, f_xunloop())

CODE("BEGIN", BEGIN, F_IMMEDIATE, f_begin())
CODE("AGAIN", AGAIN, F_IMMEDIATE, f_again())
CODE("UNTIL", UNTIL, F_IMMEDIATE, f_until())
CODE("WHILE", WHILE, F_IMMEDIATE, f_while())
CODE("REPEAT", REPEAT, F_IMMEDIATE, f_repeat())
CODE("RECURSE", RECURSE, F_IMMEDIATE, f_recurse())

CODE("CASE", CASE, F_IMMEDIATE, f_case())
CODE("OF", OF, F_IMMEDIATE, f_of())
CODE("(OF)", XOF, F_HIDDEN, f_xof())
CODE("ENDOF", ENDOF, F_IMMEDIATE, f_endof())
CODE("ENDCASE", ENDCASE, F_IMMEDIATE, f_endcase())


// main loop
CODE("QUIT", QUIT, 0, f_quit())
CODE("BYE", BYE, 0, exit(EXIT_SUCCESS))


// blocks
VAR("BLK", BLK, 0, 0)
VAR("SCR", SCR, 0, 0)
CODE("BLOCK", BLOCK, 0, f_block())
CODE("BUFFER", BUFFER, 0, f_block())
CODE("SAVE-BUFFERS", SAVE_BUFFERS, 0, f_save_buffers())
CODE("EMPTY-BUFFERS", EMPTY_BUFFERS, 0, f_empty_buffers())
CODE("FLUSH", FLUSH, 0, f_flush())
CODE("LOAD", LOAD, 0, f_load())
CODE("UPDATE", UPDATE, 0, f_update())
CODE("LIST", LIST, 0, f_list())
CODE("THRU", THRU, 0, f_thru())


// double
CODE("2CONSTANT", TWO_CONSTANT, 0, f_2constant())
CODE("(DO2CONST)", XDO2CONST, F_HIDDEN, dpush(dfetch(body)))

CODE("2VARIABLE", TWO_VARIABLE, 0, f_2variable())

CODE("2LITERAL", TWO_LITERAL, F_IMMEDIATE, comma(xtX2LITERAL); dcomma(dpop()))
CODE("(2LITERAL)", X2LITERAL, F_HIDDEN, dpush(dfetch(vm.ip)); vm.ip += DCELL_SZ)

CODE("D+", DPLUS, 0, dpush(dpop() + dpop()))
CODE("D-", DMINUS, 0, dint b = dpop(); dpush(dpop() - b))

CODE("D2*", D2MULT, 0, dpush(dpop() << 1))
CODE("D2/", D2DIV, 0, dpush(dpop() >> 1))

CODE("M*/", MSTARDIV, 0, f_m_star_slash())
CODE("M+", MPLUS, 0, f_m_plus())

CODE("D=", DEQUAL, 0, push(f_bool(dpop() == dpop())))
CODE("D<>", DDIFFERENT, 0, push(f_bool(dpop() != dpop())))
CODE("D<", DLESS, 0, dint b = dpop(); push(f_bool(dpop() < b)))
CODE("D<=", DLESS_EQUAL, 0, dint b = dpop(); push(f_bool(dpop() <= b)))
CODE("D>", DGREATER, 0, dint b = dpop(); push(f_bool(dpop() > b)))
CODE("D>=", DGREATER_EQUAL, 0, dint b = dpop(); push(f_bool(dpop() >= b)))

CODE("DU<", DU_LESS, 0, udint b = dpop(); push(f_bool((udint)dpop() < b)))
CODE("DU<=", DU_LESS_EQUAL, 0, udint b = dpop(); push(f_bool((udint)dpop() <= b)))
CODE("DU>", DU_GREATER, 0, udint b = dpop(); push(f_bool((udint)dpop() > b)))
CODE("DU>=", DU_GREATER_EQUAL, 0, udint b = dpop(); push(f_bool((udint)dpop() >= b)))

CODE("D0=", DZERO_EQUAL, 0, push(f_bool(dpop() == 0)))
CODE("D0<>", DZERO_DIFFERENT, 0, push(f_bool(dpop() != 0)))
CODE("D0<", DZERO_LESS, 0, push(f_bool(dpop() < 0)))
CODE("D0<=", DZERO_LESS_EQUAL, 0, push(f_bool(dpop() <= 0)))
CODE("D0>", DZERO_GREATER, 0, push(f_bool(dpop() > 0)))
CODE("D0>=", DZERO_GREATER_EQUAL, 0, push(f_bool(dpop() >= 0)))

CODE("D>S", DTOS, 0, push(dcell_lo(dpop())))

CODE("DABS", DABS, 0, dpush(std::abs(dpop())))
CODE("DMAX", DMAX, 0, dpush(std::max(dpop(), dpop())))
CODE("DMIN", DMIN, 0, dpush(std::min(dpop(), dpop())))
CODE("DNEGATE", DNEGATE, 0, dpush(-dpop()))


// exceptions
CODE("THROW", THROW, 0, f_throw())
CODE("CATCH", CATCH, 0, f_catch())
CODE("ABORT", ABORT, 0, f_abort())
CODE("ABORT\"", ABORT_QUOTE, F_IMMEDIATE, f_abort_quote())
CODE("(ABORT\")", XABORT_QUOTE, F_HIDDEN, f_xabort_quote())


// facility
CODE("AT-XY", AT_XY, 0, f_at_xy())
CODE("PAGE", PAGE, 0, f_page())
CODE("BEGIN-STRUCTURE", BEGIN_STRUCTURE, 0, f_begin_structure())
CODE("+FIELD", PLUS_FIELD, 0, f_plus_field())
CODE("(+FIELD)", XPLUS_FIELD, F_HIDDEN, f_xplus_field(body))
CODE("CFIELD:", CFIELD_COLON, 0, f_cfield_colon())
CODE("FIELD:", FIELD_COLON, 0, f_field_colon())
CODE("2FIELD:", TWO_FIELD_COLON, 0, f_two_field_colon())
CODE("FFIELD:", FFIELD_COLON, 0, f_f_field_colon())
CODE("SFFIELD:", SFFIELD_COLON, 0, f_f_field_colon())
CODE("DFFIELD:", DFFIELD_COLON, 0, f_f_field_colon())
CODE("END-STRUCTURE", END_STRUCTURE, 0, f_end_structure())

CODE("KEY?", KEY_QUERY, 0, f_key_query())
CODE("KEY", KEY, 0, f_key())
CODE("EKEY?", EKEY_QUERY, 0, f_ekey_query())
CODE("EKEY", EKEY, 0, f_ekey())
CODE("EKEY>CHAR", EKEY_TO_CHAR, 0, f_ekey_to_char())
CODE("EKEY>FKEY", EKEY_TO_FKEY, 0, f_ekey_to_fkey())
CONST("EMIT?", EMIT_QUERY, 0, F_TRUE)  // STDOUT is always ready for emitting

CONST("K-ALT-MASK", K_ALT_MASK, 0, MOD_ALT)
CONST("K-CTRL-MASK", K_CTRL_MASK, 0, MOD_CTRL)
CONST("K-SHIFT-MASK", K_SHIFT_MASK, 0, MOD_SHIFT)

CONST("K-UP", K_UP, 0, KEY_UP)
CONST("K-DOWN", K_DOWN, 0, KEY_DOWN)
CONST("K-LEFT", K_LEFT, 0, KEY_LEFT)
CONST("K-RIGHT", K_RIGHT, 0, KEY_RIGHT)
CONST("K-HOME", K_HOME, 0, KEY_HOME)
CONST("K-END", K_END, 0, KEY_END)
CONST("K-INSERT", K_INSERT, 0, KEY_INSERT)
CONST("K-DELETE", K_DELETE, 0, KEY_DELETE)
CONST("K-PRIOR", K_PRIOR, 0, KEY_PRIOR)
CONST("K-NEXT", K_NEXT, 0, KEY_NEXT)
CONST("K-F1", K_F1, 0, KEY_F1)
CONST("K-F2", K_F2, 0, KEY_F2)
CONST("K-F3", K_F3, 0, KEY_F3)
CONST("K-F4", K_F4, 0, KEY_F4)
CONST("K-F5", K_F5, 0, KEY_F5)
CONST("K-F6", K_F6, 0, KEY_F6)
CONST("K-F7", K_F7, 0, KEY_F7)
CONST("K-F8", K_F8, 0, KEY_F8)
CONST("K-F9", K_F9, 0, KEY_F9)
CONST("K-F10", K_F10, 0, KEY_F10)
CONST("K-F11", K_F11, 0, KEY_F11)
CONST("K-F12", K_F12, 0, KEY_F12)

CODE("MS", MS, 0, f_ms())
CODE("TIME&DATE", TIME_DATE, 0, f_time_date())


// files
CODE("R/O", R_O, 0, f_r_o())
CODE("W/O", W_O, 0, f_w_o())
CODE("R/W", R_W, 0, f_r_w())
CODE("BIN", BIN, 0, f_bin())

CODE("CREATE-FILE", CREATE_FILE, 0, f_create_file())
CODE("OPEN-FILE", OPEN_FILE, 0, f_open_file())
CODE("READ-FILE", READ_FILE, 0, f_read_file())
CODE("WRITE-FILE", WRITE_FILE, 0, f_write_file())
CODE("READ-LINE", READ_LINE, 0, f_read_line())
CODE("WRITE-LINE", WRITE_LINE, 0, f_write_line())
CODE("FILE-POSITION", FILE_POSITION, 0, f_file_position())
CODE("REPOSITION-FILE", REPOSITION_FILE, 0, f_reposition_file())
CODE("FILE-SIZE", FILE_SIZE, 0, f_file_size())
CODE("RESIZE-FILE", RESIZE_FILE, 0, f_resize_file())
CODE("FLUSH-FILE", FLUSH_FILE, 0, f_flush_file())
CODE("CLOSE-FILE", CLOSE_FILE, 0, f_close_file())
CODE("DELETE-FILE", DELETE_FILE, 0, f_delete_file())
CODE("RENAME-FILE", RENAME_FILE, 0, f_rename_file())

CODE("INCLUDED", INCLUDED, 0, f_included())
CODE("INCLUDE-FILE", INCLUDE_FILE, 0, f_include_file())
CODE("INCLUDE", INCLUDE, 0, f_include())
CODE("REQUIRE", REQUIRE, 0, f_require())
CODE("REQUIRED", REQUIRED, 0, f_required())

CODE("FILE-STATUS", FILE_STATUS, 0, f_file_status())
CONST("FS-EXISTS", FS_EXISTS, 0, FS_EXISTS)
CONST("FS-REGULAR", FS_REGULAR, 0, FS_REGULAR)
CONST("FS-DIRECTORY", FS_DIRECTORY, 0, FS_DIRECTORY)
CONST("FS-SYMLINK", FS_SYMLINK, 0, FS_SYMLINK)
CONST("FS-READABLE", FS_READABLE, 0, FS_READABLE)
CONST("FS-WRITABLE", FS_WRITABLE, 0, FS_WRITABLE)
CONST("FS-EXECUTABLE", FS_EXECUTABLE, 0, FS_EXECUTABLE)


// floating point
CODE("FLITERAL", FLITERAL, F_IMMEDIATE, comma(xtXFLITERAL); fcomma(fpop()))
CODE("(FLITERAL)", XFLITERAL, F_HIDDEN, fpush(ffetch(vm.ip)); vm.ip += FCELL_SZ)

CODE("FCONSTANT", FCONSTANT, 0, f_fconstant())
CODE("(DOFCONST)", XDOFCONST, F_HIDDEN, fpush(ffetch(body)))

CODE("FVARIABLE", F_VARIABLE, 0, f_fvariable())
CODE("(DOFVAR)", XDOFVAR, F_HIDDEN, push(body))

CODE(">FLOAT", TO_FLOAT, 0, f_to_float())
CODE("D>F", D_TO_F, 0, d_to_f())
CODE("F>D", F_TO_D, 0, f_to_d())

// only double-precision floating point supported
CODE("F!", F_STORE, 0, uint a = pop(); fstore(a, fpop()))
CODE("F@", F_FETCH, 0, uint a = pop(); fpush(ffetch(a)))
CODE("DF!", DF_STORE, 0, uint a = pop(); fstore(a, fpop()))
CODE("DF@", DF_FETCH, 0, uint a = pop(); fpush(ffetch(a)))
CODE("SF!", SF_STORE, 0, uint a = pop(); fstore(a, fpop()))
CODE("SF@", SF_FETCH, 0, uint a = pop(); fpush(ffetch(a)))

CODE("F+", F_PLUS, 0, fpush(fpop() + fpop()))
CODE("F*", F_MULT, 0, fpush(fpop() * fpop()))
CODE("F-", F_MINUS, 0, double b = fpop(); fpush(fpop() - b))
CODE("F/", F_DIV, 0, double b = fpop(); fpush(f_div(fpop(), b)))


CODE("F=", F_EQUAL, 0, push(f_bool(fpop() == fpop())))
CODE("F<>", F_DIFFERENT, 0, push(f_bool(fpop() != fpop())))
CODE("F<", F_LESS, 0, double b = fpop(); push(f_bool(fpop() < b)))
CODE("F>", F_GREATER, 0, double b = fpop(); push(f_bool(fpop() > b)))
CODE("F<=", F_LESS_EQUAL, 0, double b = fpop(); push(f_bool(fpop() <= b)))
CODE("F>=", F_GREATER_EQUAL, 0, double b = fpop(); push(f_bool(fpop() >= b)))

CODE("F0=", F_ZERO_EQUAL, 0, push(f_bool(fpop() == 0)))
CODE("F0<>", F_ZERO_DIFFERENT, 0, push(f_bool(fpop() != 0)))
CODE("F0<", F_ZERO_LESS, 0, push(f_bool(fpop() < 0)))
CODE("F0>", F_ZERO_GREATER, 0, push(f_bool(fpop() > 0)))
CODE("F0<=", F_ZERO_LESS_EQUAL, 0, push(f_bool(fpop() <= 0)))
CODE("F0>=", F_ZERO_GREATER_EQUAL, 0, push(f_bool(fpop() >= 0)))

// only double-precision floating point supported
CODE("FALIGN", FALIGN, 0, vm.dict.align())
CODE("FALIGNED", FALIGNED, 0, push(aligned(pop())))
CODE("DFALIGN", DFALIGN, 0, vm.dict.align())
CODE("DFALIGNED", DFALIGNED, 0, push(aligned(pop())))
CODE("SFALIGN", SFALIGN, 0, vm.dict.align())
CODE("SFALIGNED", SFALIGNED, 0, push(aligned(pop())))

CODE("FDROP", FDROP, 0, fpop())
CODE("FSWAP", FSWAP, 0, double a = fpop(); double b = fpop(); fpush(a); fpush(b))
CODE("FDUP", FDUP, 0, fpush(fpeek(0)))
CODE("FOVER", FOVER, 0, fpush(fpeek(1)))
CODE("FROT", FROT, 0, double c = fpop(); double b = fpop(); double a = fpop(); fpush(b); fpush(c); fpush(a))
CODE("-FROT", MINUS_FROT, 0, double c = fpop(); double b = fpop(); double a = fpop(); fpush(c); fpush(a); fpush(b))
CODE("FDEPTH", FDEPTH, 0, push(fdepth()))

// only double-precision floating point supported
CODE("FLOAT+", FLOAT_PLUS, 0, push(pop() + FCELL_SZ))
CODE("FLOATS", FLOATS, 0, push(pop() * FCELL_SZ))
CODE("DFLOAT+", DFLOAT_PLUS, 0, push(pop() + FCELL_SZ))
CODE("DFLOATS", DFLOATS, 0, push(pop() * FCELL_SZ))
CODE("SFLOAT+", SFLOAT_PLUS, 0, push(pop() + FCELL_SZ))
CODE("SFLOATS", SFLOATS, 0, push(pop() * FCELL_SZ))

CODE("FLOOR", FLOOR, 0, fpush(std::floor(fpop())))
CODE("FMAX", FMAX, 0, fpush(std::max(fpop(), fpop())))
CODE("FMIN", FMIN, 0, fpush(std::min(fpop(), fpop())))
CODE("FNEGATE", FNEGATE, 0, fpush(-fpop()))
CODE("FROUND", FROUND, 0, fpush(std::round(fpop())))
CODE("REPRESENT", REPRESENT, 0, f_represent())

CODE("F**", F_STAR_STAR, 0, double e =fpop(); fpush(pow(fpop(), e)))
CODE("F.", F_DOT, 0, print_number_fixed(fpop()))
CODE("FE.", F_E_DOT, 0, print_number_engineering(fpop()))
CODE("FS.", F_S_DOT, 0, print_number_scientific(fpop()))

CODE("S>F", S_TO_F, 0, s_to_f())
CODE("F>S", F_TO_S, 0, f_to_s())

CODE("FABS", FABS, 0, fpush(std::fabs(fpop())))

CODE("FSIN", FSIN, 0, fpush(std::sin(fpop())))
CODE("FCOS", FCOS, 0, fpush(std::cos(fpop())))
CODE("FTAN", FTAN, 0, fpush(std::tan(fpop())))

CODE("FSINH", FSINH, 0, fpush(std::sinh(fpop())))
CODE("FCOSH", FCOSH, 0, fpush(std::cosh(fpop())))
CODE("FTANH", FTANH, 0, fpush(std::tanh(fpop())))

CODE("FASIN", FASIN, 0, fpush(std::asin(fpop())))
CODE("FACOS", FACOS, 0, fpush(std::acos(fpop())))
CODE("FATAN", FATAN, 0, fpush(std::atan(fpop())))

CODE("FASINH", FASINH, 0, fpush(std::asinh(fpop())))
CODE("FACOSH", FACOSH, 0, fpush(std::acosh(fpop())))
CODE("FATANH", FATANH, 0, fpush(std::atanh(fpop())))

CODE("FATAN2", FATAN2, 0, double b = fpop(); fpush(std::atan2(fpop(), b)))
CODE("FSINCOS", FSINCOS, 0, double a = fpop(); fpush(std::sin(a)); fpush(std::cos(a)))

CODE("FLOG", FLOG, 0, fpush(std::log10(fpop())))
CODE("FALOG", FALOG, 0, fpush(std::pow(10.0, fpop())))
CODE("FEXP", FEXP, 0, fpush(std::exp(fpop())))
CODE("FLN", FLN, 0, fpush(std::log(fpop())))
CODE("FEXPM1", FEXPM1, 0, fpush(std::expm1(fpop())))
CODE("FLNP1", FLNP1, 0, fpush(std::log1p(fpop())))

CODE("FSQRT", FSQRT, 0, fpush(std::sqrt(fpop())))
CODE("FTRUNC", FTRUNC, 0, fpush(std::trunc(fpop())))
CODE("F~", F_TILDE, 0, push(f_bool(f_f_tilde())))

CODE("PRECISION", PRECISION, 0, push(vm.precision))
CODE("SET-PRECISION", SET_PRECISION, 0, uint p = pop(); if (p < 1) p = 1; if (p > MAX_PRECISION) p = MAX_PRECISION; vm.precision = p)


// locals
CODE("(LOCAL)", PAREN_LOCAL, 0, f_paren_local())
CODE("(GET_LOCAL)", PAREN_GET_LOCAL, F_HIDDEN, uint index = pop(); push(vm.r_stack.get_local(index)))
CODE("(SET_LOCAL)", PAREN_SET_LOCAL, F_HIDDEN, uint index = pop(); int value = pop(); vm.r_stack.set_local(index, value))
CODE("LOCALS|", LOCALS_BAR, F_IMMEDIATE, f_locals_bar())
CODE("{:", LOCALS_BRACKET, F_IMMEDIATE, f_locals_bracket())


// memory allocation
CODE("ALLOCATE", ALLOCATE, 0, f_allocate())
CODE("FREE", FREE, 0, f_free())
CODE("RESIZE", RESIZE, 0, f_resize())


// tools
CODE(".S", DOT_S, 0, vm.stack.print())
CODE(".RS", DOT_RS, 0, vm.r_stack.print())
CODE(".FS", DOT_FS, 0, vm.f_stack.print())
CODE("WORDS", WORDS, 0, f_words())
CODE("ENVIRONMENT?", ENVIRONMENT_Q, 0, f_environment_q())
CODE("DUMP", DUMP, 0, f_dump())
CODE("SEE", SEE, 0, f_see())
CODE("ON", ON, 0, store(pop(), F_TRUE))
CODE("OFF", OFF, 0, store(pop(), F_FALSE))
CODE("AHEAD", AHEAD, F_IMMEDIATE, f_ahead())
CODE("N>R", N_TO_R, 0, f_n_to_r())
CODE("NR>", N_R_FROM, 0, f_n_r_from())


// strings
CODE("/STRING", SLASH_STRING, 0, f_slash_string())

#undef CONST
#undef VAR
#undef CODE
#undef FORTH
